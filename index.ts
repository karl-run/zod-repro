import { parseISO, isValid } from "date-fns";
import { z, ZodType } from "zod";

export const LocalDateSchema = z
  .string()
  .refine((date) => isValid(parseISO(date)), { message: "Invalid date string" })
  .transform((date) => parseISO(date));

async function thisWorksWithNoDate() {
  const SchemaNoDate = z.object({
    a: z.string(),
    b: z.string(),
    c: z.string(),
  });

  /** This would be generated by GraphQL Code Generator */
  interface CompatibleGraphQLSchemaNoDate {
    a: string;
    b: string;
    c: string;
  }

  const works: CompatibleGraphQLSchemaNoDate = await genericFetcher({
    path: "/foo",
    schema: SchemaNoDate,
  });
}

async function reproTheThingWithDate() {
  const SchemaWithDate = z.object({
    a: z.string(),
    date: LocalDateSchema,
    c: z.string(),
  });

  interface CompatibleGraphQLSchemaWithDate {
    a: string;
    date: Date;
    c: string;
  }

  // The types of '_input.date' are incompatible between these types. Type 'string' is not assignable to type 'Date'.ts(2322)
  const doesNotWork: CompatibleGraphQLSchemaWithDate = await genericFetcher({
    path: "/foo",
    schema: SchemaWithDate,
  });
}

async function genericFetcher<SchemaType>({
  path,
  schema,
}: {
  path: string;
  schema: ZodType<SchemaType>;
}): Promise<SchemaType> {
  const response = await fakeFetch(path);
  const responseJson = await response.json();
  const result = schema.safeParse(responseJson);
  if (result.success) {
    return result.data;
  }

  throw new Error(`Unable to parse response`);
}

/**
 * Only used for reproduction
 */
async function fakeFetch(path: string): Promise<{ json: () => Promise<any> }> {
  return {
    json: () => Promise.resolve({}),
  };
}
